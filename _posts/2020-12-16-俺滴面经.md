---
layout:     post
title:      俺滴面经
subtitle:   
date:       2020-12-16
author:     孙继峰
header-img: img/th.jpg
catalog: true
tags:
    - 面经
---



> 真心希望这种"面试造火箭, 工作骑单车"的行业现行尽快改变. 搞这种船货崇拜](https://mp.weixin.qq.com/s/sgDZ00aPzbh_YzXlebEX-w)真心没意思, 但是社会又很追捧这种现象, 无奈于现状, 想进大厂、高薪资就需要走这条路.



## 有用过锁吗?

有用到 ```synchronized```、```Lock``` 与基于 Redis 的分布式锁.

```synchronized``` 一开始并不重, 只是经过锁膨胀之后才慢慢变得重. 一开始只是无锁状态, 当一个线程获取锁时, 线程可以直接获取锁, 这时候膨胀为偏向锁, 通过比较 ThreadID 进行加锁. 当有多个线程交替获取锁时, 会膨胀为轻量级锁, 通过自选等待来加锁. 当有多个线程同时获取锁时, 会膨胀为重量级锁, 通过操作系统的 mutex 锁进行互斥, 这时候的消耗才是最高的, 申请和释放锁时都需要从用户态切换到内核态再切回用户态.

```Lock``` 的底层实现基于 ```Unsafe::compareAndSet``` 方法, 对 ```volatile``` 变量进行 CAS 操作来进行加锁. ```Unsafe::compareAndSet``` 使用这个方法将工作内存与主内存的值比较, 成功则赋值.  ```volatile``` 的语义, 它能保证对这个变量的写操作能立即导致其他线程的工作内存失效, 直接从主内存中获取该变量. ```volatile``` 与 ```Unsafe::compareAndSet```结合完成锁的功能.

基于 Redis 的分布式锁是使用开源客户端 [Redisson](https://github.com/redisson/redisson) 实现的. Redisson 本身提供了分布式锁的实现, 底层原理是基于 Lua Script, 加锁发送给 Redis Server 一段 Lua Script, 其中逻辑就是如果没有锁(```exist```), 那就加锁(```hset```)并设置过期时间(```pexpire```). 如果锁已存在(```hexists```), 就叠加一层锁(```hincrby```), 再续锁(```pexpire```). 使用 Lua Script 保证执行原子性. Redisson 的 API 都是基于 JUC 接口实现的, 锁是可重入锁, 加锁几次就需要解锁几次.