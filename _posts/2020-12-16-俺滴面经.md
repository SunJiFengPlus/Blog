---
layout:     post
title:      俺滴面经
subtitle:   
date:       2020-12-16
author:     孙继峰
header-img: img/th.jpg
catalog: true
tags:
    - 面经
---



> 真心希望这种"面试造火箭, 工作骑单车"的行业现行尽快改变. 搞这种船货崇拜](https://mp.weixin.qq.com/s/sgDZ00aPzbh_YzXlebEX-w)真心没意思, 但是社会又很追捧这种现象, 无奈于现状, 想进大厂、高薪资就需要走这条路.



## 有用过锁吗?

有用到 ```synchronized```、```Lock``` 与基于 Redis 的分布式锁.

```synchronized``` 一开始并不重, 只是经过锁膨胀之后才慢慢变得重. 一开始只是无锁状态, 当一个线程获取锁时, 线程可以直接获取锁, 这时候膨胀为偏向锁, 通过比较 ThreadID 进行加锁. 当有多个线程交替获取锁时, 会膨胀为轻量级锁, 通过自选等待来加锁. 当有多个线程同时获取锁时, 会膨胀为重量级锁, 通过操作系统的 mutex 锁进行互斥, 这时候的消耗才是最高的, 申请和释放锁时都需要从用户态切换到内核态再切回用户态.

```Lock``` 的底层实现基于 ```Unsafe::compareAndSet``` 方法, 对 ```volatile``` 变量进行 CAS 操作来进行加锁. ```Unsafe::compareAndSet``` 使用这个方法将工作内存与主内存的值比较, 成功则赋值.  ```volatile``` 的语义, 它能保证对这个变量的写操作能立即导致其他线程的工作内存失效, 直接从主内存中获取该变量. ```volatile``` 与 ```Unsafe::compareAndSet```结合完成锁的功能.

基于 Redis 的分布式锁是使用开源客户端 [Redisson](https://github.com/redisson/redisson) 实现的. Redisson 本身提供了分布式锁的实现, 底层原理是基于 Lua Script, 加锁发送给 Redis Server 一段 Lua Script, 其中逻辑就是如果没有锁(```exist```), 那就加锁(```hset```)并设置过期时间(```pexpire```). 如果锁已存在(```hexists```), 就叠加一层锁(```hincrby```), 再续锁(```pexpire```). 使用 Lua Script 保证执行原子性. Redisson 的 API 都是基于 JUC 接口实现的, 锁是可重入锁, 加锁几次就需要解锁几次.




## 商品服务从0到1的过程
背景: 商品逻辑耦合于上游各个服务之间, 痛点就是难于管理, 决定拆分沉淀为商品服务.
确定通用语言: 为避免和产品、测试、开发人员沟通歧义, 我们首先确定了通用语言, 按照商品的生命周期划分出了几个概念, 我们把商家上传的商品叫商品审核单, 审核通过后买家可见的商品叫浏览商品, 买家下单的商品叫订单项, 退款流程中的商品叫商品售后单.
确定服务边界: 这个流程主要的目的就是确定哪些逻辑商品服务需要处理, 哪些逻辑商品服务不需要处理. 比如查询商品的活动价格, 按照行为名称看是和商品有关系, 但是仔细分析活动是属于运营子域的, 活动价也是运营子域的内容.
任务分解: 将每一个接口拆分成若干个 case, 去找测试、产品、原来的维护者确认, 避免开发完成后的扯皮与返工. 每一个 case 最后以测试用例的形式验证, 通过测试用例了, 就证明代码是可工作的, 功能是被测试、产品、原维护者认可的.

编写测试用例，写代码，通过测试用例，通过check style静态检查，找人review，测试，预发布，上线.