---
layout:     post
title:      俺滴面经
subtitle:   
date:       2020-12-16
author:     孙继峰
header-img: img/th.jpg
catalog: true
tags:
    - 面经
---



> 真心希望这种"面试造火箭, 工作骑单车"的行业现行尽快改变. 搞这种[船货崇拜](https://mp.weixin.qq.com/s/sgDZ00aPzbh_YzXlebEX-w)真心没意思, 但是社会又很追捧这种现象, 无奈于现状, 想进大厂、高薪资就需要走这条路.



## 有用过锁吗?

有用到 ```synchronized```、```Lock``` 与基于 Redis 的分布式锁.

```synchronized``` 一开始并不重, 只是经过锁膨胀之后才慢慢变得重. 一开始只是无锁状态, 当一个线程获取锁时, 线程可以直接获取锁, 这时候膨胀为偏向锁, 通过比较 ThreadID 进行加锁. 当有多个线程交替获取锁时, 会膨胀为轻量级锁, 通过自选等待来加锁. 当有多个线程同时获取锁时, 会膨胀为重量级锁, 通过操作系统的 mutex 锁进行互斥, 这时候的消耗才是最高的, 申请和释放锁时都需要从用户态切换到内核态再切回用户态.

```Lock``` 的底层实现基于 ```Unsafe::compareAndSet``` 方法, 对 ```volatile``` 变量进行 CAS 操作来进行加锁. ```Unsafe::compareAndSet``` 使用这个方法将工作内存与主内存的值比较, 成功则赋值.  ```volatile``` 的语义, 它能保证对这个变量的写操作能立即导致其他线程的工作内存失效, 直接从主内存中获取该变量. ```volatile``` 与 ```Unsafe::compareAndSet```结合完成锁的功能.

基于 Redis 的分布式锁是使用开源客户端 [Redisson](https://github.com/redisson/redisson) 实现的. Redisson 本身提供了分布式锁的实现, 底层原理是基于 Lua Script, 加锁发送给 Redis Server 一段 Lua Script, 其中逻辑就是如果没有锁(```exist```), 那就加锁(```hset```)并设置过期时间(```pexpire```). 如果锁已存在(```hexists```), 就叠加一层锁(```hincrby```), 再续锁(```pexpire```). 使用 Lua Script 保证执行原子性. Redisson 的 API 都是基于 JUC 接口实现的, 锁是可重入锁, 加锁几次就需要解锁几次.




## 商品服务从0到1的过程
背景: 商品逻辑耦合于上游各个服务之间, 痛点就是难于管理, 决定拆分沉淀为商品服务.

确定通用语言: 为避免和产品、测试、开发人员沟通歧义, 我们首先确定了通用语言, 按照商品的生命周期划分出了几个概念, 我们把商家上传的商品叫商品审核单, 审核通过后买家可见的商品叫浏览商品, 买家下单的商品叫订单项, 退款流程中的商品叫商品售后单.

确定服务边界: 这个流程主要的目的就是确定哪些逻辑商品服务需要处理, 哪些逻辑商品服务不需要处理. 比如查询商品的活动价格, 按照行为名称看是和商品有关系, 但是仔细分析活动是属于运营子域的, 活动价也是运营子域的内容.

任务分解: 将每一个接口拆分成若干个 case, 去找测试、产品、原来的维护者确认, 避免开发完成后的扯皮与返工. 每一个 case 最后以测试用例的形式验证, 通过测试用例了, 就证明代码是可工作的, 功能是被测试、产品、原维护者认可的.

编写测试用例，写代码，通过测试用例，通过check style静态检查，找人review，测试，预发布，上线.



## 解决过哪些技术难题?

背景: Gateway里打印了接口名与相应时间, 日志收集中配置了报警, 依赖报警感知接口超时率.

#### 1.接口超时

排查: 从请求体上看一次请求了1000多个资源, 与上游业务确认后确定是正常的用户请求. 从代码中看不出任何猫腻, 借助 Arthas attach 到线上应用后对接口方法链路进行耗时分析.发现两处验证耗时的地方, 将 redis client 返回的数据(本身是Map结构,K:属性名, V:属性值)序列化为 json 又序列化为领域对象, 另一个是对象拷贝(```BeanUtils::copyProperty```).

解决: 使用 Hutool 的 ```BeanUtil::toBean``` 直接把 Map 转换为 Bean, 将属性拷贝全部替换为 Setter

验证: 运行全部测试用例, 确保未破坏已有功能, 运行JMH, 确保重构后的接口将再当前场景下不会再超时.



#### 2.Redis 查询慢

排查: Arthas attach 线程观察到 redis client 执行缓慢, 找运维人员确认 RDS-Redis 实例, 连接数有波峰.

分析: 项目中有一些极其不恰当的 Redis 实践, 把整个表的数据都使用一个 Hash Key 存储了, 根据28原则, 那肯定也有大量长时间不被访问的 field. 更改存储结构需要改动很多点, 代价比较大.

解决: 使用 Redisson 的 ```RMapCache``` 对每一个 Field 设置过期时间, Redisson 用定时任务去删除过期的 Field.



#### 3. 数据库死锁

排查: 错误都在log里写明白的  ```Deadlock found when trying to get lock; try restarting transaction```

分析: 异常在 MyBatis-Plus 的  ```ServiceImpl::updateBatchById``` 方法中抛出,  在执行```SqlSession::flushStatements``` 时会去对库里的记录加锁, 在并发情况下批量更新用户1、用户2, 与更新用户2、用户1, 获取锁的顺序不一致, 一个事务持有了用户1的锁, 请求用户2, 另外一个事务持久用户2的锁, 请求用户1的锁, 从而导致死锁.

解决: 破坏一个死锁的必要条件: **循环等待**. 把这个条件破坏掉就可以了, 对于要进行批量更新的数据, 对其安装id排序, 在进行批量更新就没有问题了.



## SQL 优化有做过吗?







## 了解垃圾回收吗?

## 高并发有遇到过吗?

## AOP在哪里应用

## HTTP请求全流程

## TCC 流程

## 如何应对高并发

## 用过 Spring Cloud 哪些组件?

## 谈谈你对 Springboot Starter 的理解

## MQ 的架构

## 你有什么问题想问我?

平时有写测试吗？测试覆盖率有多少？

内部有技术分享吗？多久一次？

有统一的Code Style吗?

流水线都有哪些流程?

