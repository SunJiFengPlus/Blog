---
layout:     post
title:      基于Arthas的接口优化实践
subtitle:   
date:       2020-11-6
author:     孙继峰
header-img: img/th.jpg
catalog: true
tags:
	- 优化
---

#### 背景
近期线上接口频繁超时, 通过日志收集工具发现, 在请求量没有大幅增加时这个接口频繁超时.



#### 定位问题
我首先去确认了这些请求的请求内容是不是特别大.

<img src="https://i.loli.net/2020/11/09/k2mo4OBTXC3nUpA.png" style="zoom:50%;" />

果然, 好家伙一次请求了1000多个资源, 这不慢才怪.
但是即使是请求了这么多资源也是业务的正常需求, 需要支持! 咋办? 优化呗!



#### 使用Arthas定位耗时节点

其实我很希望能在线上环境运行Arthas, 但是由于权限不足, 申请还挺麻烦, 
即是能在线上机器上运行Arthas, 我也会慌得一批, 生怕影响到应用. 所以还是选择了在测试环境操作.


启动Arthas, attach 上测试应用, 执行下面的命令
```shell script
 trace -n 3 -E com.ofashion.service.goodscenter.service.goods.impl.GoodsServiceImpl getGoodsInfoList '#cost>2000'
```
命令的作用是: 当 getGoodsInfoList 这个方法执行时长超过2000毫秒时则输出耗时记录, 输出3次后进行tear down

另外一边启动JMeter, 并发的请求大量资源.

从库里查出1000条商品id

![](https://i.loli.net/2020/11/10/yb9fBMjKP85YXmq.png)

使用正则表达式在商品id前面加上: ```"``` 后面加上: ```",```

<img src="https://i.loli.net/2020/11/10/rBK9w256CYP4GRT.png" style="zoom:67%;" />

填充到JMeter中, 并发请求测试环境

<img src="https://i.loli.net/2020/11/10/wJ2aHc76gbs1fOQ.png" style="zoom: 40%;" />

在Arthas控制台上能看到方法的链路耗时, 经过几轮定位后发现几个耗时严重的操作.



![](https://i.loli.net/2020/11/10/W1ELb4RFOlrXnIu.png)



发现有以下几个耗时节点:

- ```RedisUtil::hMGet``` 中的反序列化
- 商品的DO与VO之间的属性拷贝



#### 优化耗时节点

```RedisUtil::hMGet```代码如下

```java
public <T> List<T> hMGet(Object key, Collection fields, Class<T> clazz) {
				List<Object> objects = redisTemplate.opsForHash().multiGet(key, fields);
        objects = objects.stream().filter(Objects::nonNull).collect(Collectors.toList());
        // 这一步耗时严重
        return JsonUtil.convertedToArray(JsonUtil.toJson(objects), clazz);
}  
```

这里在处理时直接把redis客户端返回的数据序列化再反序列化为List, 处理逻辑上没什么问题

通过debug发现redis客户端返回的结构是```ArrayList<LinkedTreeMap<String, Object>>```

![](https://i.loli.net/2020/11/10/JYvR8Tdm4oQD7S5.png)

那当前这种先序列化再反序列化的方式就有些浪费资源了, 没有利用上Map的结构, 使用BeanUtil替换反序列化的这一步

得到了以下的代码.

```java
    public <T> List<T> hMGet(Object key, Collection fields, Class<T> clazz) {
        List<Object> objects = redisTemplate.opsForHash().multiGet(key, fields);
        return objects.stream().filter(Objects::nonNull)
                .map(object -> BeanUtil.toBean(object, clazz))
                .collect(Collectors.toList());
    }
```

运行测试用例

![](https://i.loli.net/2020/11/10/gVPfksOxDqbmYh2.png)

OK, 这次修改没有影响软件的可观察行为, 这个方法还是可工作的.

